{
  "name": "matches",
  "version": "0.5.1",
  "author": {
    "name": "Nathan Faubion",
    "email": "nathan@n-son.com"
  },
  "description": "Powerful pattern matching for Javascript",
  "scripts": {
    "test": "mocha -u tdd"
  },
  "main": "./matches",
  "repository": {
    "type": "git",
    "url": "https://github.com/natefaubion/matches.js.git"
  },
  "keywords": [
    "matching",
    "patterns",
    "pattern",
    "match",
    "functional"
  ],
  "devDependencies": {
    "mocha": "*",
    "adt": "0.5.x",
    "benchmark": "1.0.x",
    "uglify-js": "1.3.x"
  },
  "license": "MIT",
  "readme": "matches.js\n==========\n\nMatches.js brings the power and expressiveness of pattern matching to \nJavascript.\n\nInstall\n-------\n\n`npm install matches`\n\n```js\nvar pattern = require(\"matches\").pattern;\nvar mymap = pattern({\n  '_, []' : function () { \n    return [];\n  },\n  'f, [x, ...xs]' : function (f, x, xs) {\n    return [f(x)].concat(mymap(f, xs));\n  }\n});\n\n// [2, 4, 6, 8]\nmymap(function (x) { return x * 2; }, [1, 2, 3, 4]);\n```\n\nPatterns\n--------\n\n### Literals\n\nCheck for specific values using number or string literals, `null`, or \n`undefined`.\n\n```js\nvar myfn = pattern({\n  // Null\n  'null' : function () {...},\n\n  // Undefined\n  'undefined' : function () {...},\n\n  // Numbers\n  '42'    : function () { ... },\n  '12.6'  : function () { ... },\n  '1e+42' : function () { ... },\n\n  // Strings\n  '\"foo\"' : function () { ... },\n\n  // Escape sequences must be double escaped.\n  '\"This string \\\\n matches \\\\n newlines.\"' : function () { ... }\n});\n```\n\n### Wildcards\n\nUnderscores will match successfully on any value but ignore it.\n\n```js\nvar myfn = pattern({\n  // Match if second argument is 12, ignoring the first\n  '_, 12' : function () { ... }\n});\n```\n\n### Identifiers\n\nPatterns that start with lowercase letters will pass the value to the function.\nValues are passed to the function in the same right to left order they are\ndeclared in the pattern.\n\n```js\nvar myfn = pattern({\n  // Pass on the second argument if the first is 12\n  '12, x': function (x) { ... },\n\n  // Pass on the first and third argument, ignoring the second\n  'x, _, y': function (x, y) { ... }\n});\n```\n\n### Rest Arguments\n\nUse an ellipsis for rest arguments. A single ellipsis works as a catch all\npattern.\n\n```js\nvar myfn = pattern({\n  // Match if first argument is 12, get all the rest as an array\n  '12, ...args': function (args) { ... },\n\n  // Get the last argument\n  '..., x': function (x) { ... },\n\n  // Match on anything and any number of arguments\n  '...': function () { ... }\n});\n```\n\n### Arrays\n\nMatch on the entire array, or only a few values.\n\n```js\nvar myfn = pattern({\n  // Empty array\n  '[]' : function () { ... },\n\n  // Strict comparison on contents\n  '[1, 2, 3]': function () { ... },\n\n  // Grab the first value, ignoring the rest\n  '[x, ...]': function (x) { ... },\n\n  // Split it into a head and tail\n  '[head, ...tail]': function (head, tail) { ... },\n\n  // Grab the first and last items, ignoring the middle\n  '[x, ..., y]': function (x, y) { ... },\n\n  // Grab the last item\n  '[..., last]': function (last) { ... },\n\n  // Make a shallow clone\n  '[...clone]': function (clone) { ... },\n\n  // Grab the first item, but also pass on the whole array\n  'arr@[first, ...]': function (arr, first) { ... }\n});\n```\n\n### Rest Expressions\n\nRests (`...`) can do more than just split up an array. You can combine them\nwith arbitrary patterns to apply said pattern across every element in the array.\n\n```js\nvar myfn = pattern({\n  // Make sure every element is a string\n  '[...String]': function () { ... },\n\n  // Extract values from tuples\n  '[...[x, y]]': function (xs, ys) { ... },\n\n  // Extract values from objects\n  '[...{name}]': function (names) { ... },\n\n  // You can even nest rest expressions\n  '[...[head, ...tail]]': function (heads, tails) { ... }\n});\n```\n\n### Objects\n\nLike with an array, you can match on an entire object, or just a few keys.\nUnlike arrays, matching is only non-strict. It checks that the keys exist, but\nother keys are allowed to exist in the object.\n\n```js\nvar myfn = pattern({\n  // Empty object\n  '{}': function () { ... },\n\n  // Check that an object has two keys 'x' and 'y', and pass to the function\n  '{x, y}': function (x, y) { ... },\n\n  // Check that an object has a key 'children' that contains an array\n  '{children: [a, b]}': function (a, b) { ... },\n})\n```\n\n### Core Javascript Types\n\nTypecheck arguments using `Number`, `String`, `Date`, `RegExp`, `Function`,\n`Array`, or `Object`.\n\n```js\nvar myfn = pattern({\n  // Takes a function and an array\n  'fn@Function, arr@Array': function (fn, arr) { ... },\n\n  // Takes a function and an object\n  'fn@Function, obj@Object': function (fn, obj) { ... }\n});\n```\n\n### Custom Types\n\nYou can add pattern matching support for your own classes.\n\n```js\n// Create a new class\nfunction MyClass () {\n  this.val = 1;\n}\n\n// Matches.js will check for the non-standard attribute `name` on the constructor\n// function. If you are in the browser and want wider support, or are using\n// anonymous functions, make sure you tag your constructor with `className`.\nMyClass.className = \"MyClass\";\n\n// Add the static method `unapply` for array-like matching.\nMyClass.unapply = function (obj) {\n  return [obj.val];\n};\n\n// Add the static method `unapplyObj` for object-like matching.\nMyClass.unapplyObj = function (obj) {\n  return {\n    'val': obj.val\n  };\n};\n\n// Now you can match on your object.\nvar myfn = pattern({\n  // Type-checking\n  'MyClass': function () { ... },\n\n  // Array-like matching\n  'MyClass(a)': function (a) { ... },\n\n  // Object-like matching\n  'MyClass{val: a}': function (a) { ... }\n});\n```\n\n### Adt.js Types\n\nAdt.js ships with builtin support for matches.js. Adt.js is a library for\nbuilding algebraic data types or case classes in Javascript.\n\n```js\n// Create a new adt.js type\nvar Tree = adt.data({\n  Empty : adt.single(),\n  Node  : adt.record(\"val\", \"left\", \"right\")\n});\n\nvar mytree = Tree.Node(12, Tree.Empty, Tree.Node(42, Tree.Empty, Tree.Empty);\n\nvar myfn = pattern({\n  // Match on an Empty tree node\n  'Empty': function () { ... },\n\n  // Match on a Node with a value of 12\n  'Node(12, ...)': function () { ... },\n\n  // Match using named keys\n  'Node{val: 12}': function () { ... },\n\n  // Match on a Node that has non-Empty children\n  'Node(_, Node, Node)': function () { ... }\n\n  // Match on a Node that has a left child Node of 42 and an Empty right node\n  'Node(val, Node(42, _, _), Empty)': function (val) { ... }\n});\n```\n\nFind out more about adt.js: https://github.com/natefaubion/adt.js\n\n### Custom Extractors\n\nExtend matches.js with custom extractors.\n\n```js\n// Naive email extractor.\n// Extractors are passed the value, and a `pass` function. In order to count as\n// a successful match, the extractor must return an instance of pass.\nmatches.extractors.email = function (val, pass) {\n  if (typeof val === \"string\" && val.indexOf(\"@\") > 0) {\n    var parts = val.split(\"@\");\n    return pass({\n      user: parts[0],\n      domain: parts[1]\n    });\n  }\n};\n\nvar myfn = pattern({\n  // Extractors are called by prefixing the name with a $\n  '$email(x)': function (x) { ... },\n\n  // Match on the extracted value\n  '$email(x@{domain: \"foo.com\"})': function (x) { ... }\n});\n```\n\nUsage\n-----\n\nMatches.js exports four functions, `pattern`, `caseOf`, `extract`, and\n`extractOne`.\n\n```js\nvar matches = require(\"matches\");\nvar pattern = matches.pattern;\nvar caseOf  = matches.caseOf;\nvar extract = matches.extract;\nvar extractOne = matches.extractOne;\n```\n\n### pattern(patternObj)\n\nThe simplest way is to give it an object with the keys being patterns, and the\nvalues being functions. Each pattern will be tried in order until a match is\nfound.\n\n```js\nvar arrayElems = pattern({\n  '[]': function () { \n    return \"This array is empty.\"; \n  },\n  '[x]': function (x) { \n    return \"This array has one element: \" + x; \n  },\n  '[x, y]': function (x, y) { \n    return \"This array has two elements: \" + x + \" and \" + y;\n  },\n  '[x, y, ...]': function (x, y) {\n    return \"This array is long. The first two elements are: \" + x + \" and \" + y;\n  }\n});\n\narrayElems([1, 2, 3]);\n```\n\n### pattern(patternStr, successFn)\n\nYou can create individual pattern and function pairs.\n\n```js\nvar emptyArray = pattern('[]', function () { return \"Empty array\" });\n\n// \"Empty array\"\nemptyArray([]);\n\n// TypeError: \"All patterns exhausted\"\nemptyArray(12);\n```\n\n### pattern(patternFn, successFn)\n\nYou can also create your own custom pattern functions. The `patternFn` takes\nan array of arguments, and should return `false` for no match, or a new array\nof arguments to forward on to the `successFn`.\n\n```js\nvar greater42 = function (args) {\n  if (args[0] >= 42) return [args[0]];\n  return false;\n};\n\nvar customPattern = pattern(greater42, function (x) {\n  console.log(x);\n});\n\n// Logs 54\ncustomPattern(54);\n\n// TypeError: \"All patterns exhausted\"\ncustomPattern(12);\n```\n\n### caseOf(...args, patternObj)\n\nYou can use `caseOf` to do ad-hoc pattern matching on objects. It's the same\nas immediately invoking a `pattern` function, but lets you put the arguments\nfirst.\n\n```js\nvar result = caseOf(42, {\n  'x@Number' : function (x) { return x * 2; },\n  '_'        : function () { return null; }\n});\n\n// Is the same as...\nvar result = pattern({\n  // ...\n})(42);\n```\n\n### extract(patternStr, ...args)\n\nUse extract to pull values out of other values. It works much like `match` on\nstrings. If there was a succesful match, it will return an array of extracted\nvalues. If the match failed, it will return `null`.\n\n```js\nvar res = extract('[...{name}]', objArray);\n```\n\n### extractOne(patternStr, ...args)\n\nThis is like `extract` but returns the first value instead of an array. This\nworks well for traversing a deep structure.\n\n```js\nvar val = extractOne('{some: {nested: {structure: val}}}', obj);\n```\n\n*Note:* this will also return `undefined` on failure. So keep that in mind if \n`undefined` could be a valid value.\n\n### Combinators\n\nYou can combine any of these methods to create unique match chains using the\n`alt` combinator.\n\n```js\n\nvar wildcard = pattern('_', function () { return \"No matches.\"; });\nvar mychain = pattern('1', function () { return \"One\"; })\n  .alt({\n    '2': function () { return \"Two\"; },\n    '3': function () { return \"Three\"; }\n  })\n  .alt(wildcard);\n\n// 'One'\nmychain(1);\n\n// 'Two'\nmychain(2);\n\n// 'No matches.'\nmychain(5);\n```\n\n### Multiple Arguments\n\nSeparate matches for multiple arguments with a comma. Since you can pass any\nnumber of arguments to functions in Javascript, Matches.js is not strict and\nwill happily combine patterns for varying numbers of arguments. However,\nMatches.js is strict on the number of arguments within the pattern.\n\n```js\nvar myfn = pattern({\n  // Matches on exactly three arguments\n  '1, \"foo\", [a, ...]': function (a) { return a; },\n\n  // Matches on the first two arguments, ignoring the rest\n  'a, fn@Function, ...': function (a, fn) { return fn(a); },\n\n  // Matches anything\n  '...': function () { return null; }\n});\n```\n\n### Performance\n\nPattern strings are compiled to pure Javascript functions and then cached, so\nin general, they are quite fast.\n\nOn a 2GHz core, average compilation time is around .12ms for a pattern\ncomprised of 5-6 sub-patterns. Pattern matched functions are around 3-4x slower\nto dispatch than an equivalent hand-optimized function that does similar\ntype-checking. Keep in mind, that time is measured in the single microseconds \n(1µs vs 3µs) to dispatch 5 calls to the same function.\n",
  "readmeFilename": "README.md",
  "_id": "matches@0.5.1",
  "dist": {
    "shasum": "913fc62bb46ebfcf1385fc6594742dba02a2ccec",
    "tarball": "https://registry.npmjs.org/matches/-/matches-0.5.1.tgz"
  },
  "_npmVersion": "1.1.69",
  "_npmUser": {
    "name": "natefaubion",
    "email": "nathan@n-son.com"
  },
  "maintainers": [
    {
      "name": "natefaubion",
      "email": "nathan@n-son.com"
    }
  ],
  "directories": {},
  "_shasum": "913fc62bb46ebfcf1385fc6594742dba02a2ccec",
  "_from": "matches@",
  "_resolved": "https://registry.npmjs.org/matches/-/matches-0.5.1.tgz"
}
